# Autogenerated for the BU2402001 variant
core_addr = "192.168.0.2"
server_addr = "137.222.69.28"
# default_core_addr = "192.168.1.75"

# standard core components
device_db = {
    "core": {
        "type": "local",
        "module": "artiq.coredevice.core",
        "class": "Core",
        "arguments": {
            "host": core_addr,
            "ref_period": 1e-09,
            "target": "rv32g",
            "analyzer_proxy": "core_analyzer",
        },
    },
    "core_log": {
        "type": "controller",
        "host": server_addr,
        "port": 1068,
        "command": "aqctl_corelog -p {port} --bind {bind} " + core_addr,
    },
    "core_analyzer": {
        "type": "controller",
        "host": server_addr,
        "port_proxy": 1385,
        "port": 1386,
        "command": "aqctl_coreanalyzer_proxy --port-proxy {port_proxy} --port-control {port} --bind {bind} "
        + core_addr,
    },
    "core_moninj": {
        "type": "controller",
        "host": server_addr,
        "port_proxy": 1383,
        "port": 1384,
        "command": "aqctl_moninj_proxy --port-proxy {port_proxy} --port-control {port} --bind {bind} "
        + core_addr,
    },
    "core_cache": {
        "type": "local",
        "module": "artiq.coredevice.cache",
        "class": "CoreCache",
    },
    # allows for direct memory access of RTIO events to play back faster than the cpu can
    "core_dma": {"type": "local", "module": "artiq.coredevice.dma", "class": "CoreDMA"},
    #     I2C switches
    "i2c_switch0": {
        "type": "local",
        "module": "artiq.coredevice.i2c",
        "class": "I2CSwitch",
        "arguments": {"address": 0xE0},
    },
    "i2c_switch1": {
        "type": "local",
        "module": "artiq.coredevice.i2c",
        "class": "I2CSwitch",
        "arguments": {"address": 0xE2},
    },
}

# DAC = Digital to Analog Converter
# 32 channels 16bit DAC
device_db["fastino"] = {
    "type": "local",
    "module": "artiq.coredevice.fastino",
    "class": "Fastino",
    "arguments": {"channel": 0, "log2_width": 0},
}

# freq synthesiser 50MHz - 4GHz (6.8GHz-ish if pushed)
# boosted to 5GHz - 12GHz by the almazny
# SPI = Serial Peripheral Interface
device_db["spi_mirny"] = {
    "type": "local",
    "module": "artiq.coredevice.spi2",
    "class": "SPIMaster",
    "arguments": {"channel": 1},
}
device_db["mirny_cpld"] = {
    "type": "local",
    "module": "artiq.coredevice.mirny",
    "class": "Mirny",
    "arguments": {"spi_device": "spi_mirny", "refclk": 125000000.0, "clk_sel": "mmcx"},
}

for i in range(4):
    device_db.update(
        {
            "ttl_mirny_sw"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.ttl",
                "class": "TTLOut",
                "arguments": {"channel": 2 + i},
            },
            "mirny_ch"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.adf5356",
                "class": "ADF5356",
                "arguments": {
                    "channel": i,
                    "sw_device": "ttl_mirny_sw" + str(i),
                    "cpld_device": "mirny_cpld",
                },
            },
        }
    )

# device_db.update(
#     {
#         "mirny_almazny": {
#             "type": "local",
#             "module": "artiq.coredevice.almazny",
#             "class": "AlmaznyLegacy",
#             "arguments": {
#                 "host_mirny": "mirny_cpld",
#             },
#         },
#     }
# )
for i in range(4):
    device_db.update(
        {
            "almazny_ch"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.almazny",
                "class": "AlmaznyChannel",
                "arguments": {
                    "host_mirny": "mirny_cpld",
                    "channel": i,
                },
            }
        }
    )

# 4x4 TTL IOs - switched by sets of 4
# NB ttl0-ttl3 are OUT only
for i in range(4):
    device_db.update(
        {
            "ttl"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.ttl",
                "class": "TTLOut",
                "arguments": {"channel": 6 + i},
            }
        }
    )
# next set of 4 are in/out and can be used as counters
for i in range(4):
    device_db.update(
        {
            "ttl"
            + str(i + 4): {
                "type": "local",
                "module": "artiq.coredevice.ttl",
                "class": "TTLInOut",
                "arguments": {"channel": 10 + i},
            },
            "ttl"
            + str(i + 4)
            + "_counter": {
                "type": "local",
                "module": "artiq.coredevice.edge_counter",
                "class": "EdgeCounter",
                "arguments": {"channel": 14 + i},
            },
        }
    )
# the last 8 are also in/out and can be used as counters
for i in range(8):
    device_db.update(
        {
            "ttl"
            + str(i + 8): {
                "type": "local",
                "module": "artiq.coredevice.ttl",
                "class": "TTLInOut",
                "arguments": {"channel": 18 + i},
            },
            "ttl"
            + str(i + 8)
            + "_counter": {
                "type": "local",
                "module": "artiq.coredevice.edge_counter",
                "class": "EdgeCounter",
                "arguments": {"channel": 26 + i},
            },
        }
    )

# SU Servo is an 8-channel ADC (Sampler) and two 4-channel DDS (Urukuls) with a DSP engine
# connecting the ADC data and the DDS output amplitudes to enable feedback.
# It can be used to implement intensity stabilization of laser beams
# with an amplifier and AOM driven by Urukul and a photodetector connected to Sampler.

# PGIA = Programmable Gain Instrumentation Amplifier
# CPLD = Complex Programmable Logic Device
# DDS = Direct Digital Synthesis
device_db["suservo"] = {
    "type": "local",
    "module": "artiq.coredevice.suservo",
    "class": "SUServo",
    "arguments": {
        "channel": 42,
        "pgia_device": "spi_sampler_pgia",
        "cpld_devices": ["urukul0_cpld", "urukul1_cpld"],
        "dds_devices": ["urukul0_dds", "urukul1_dds"],
    },
}
for i in range(8):
    device_db.update(
        {
            "suservo_ch"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.suservo",
                "class": "Channel",
                "arguments": {"channel": 34 + i, "servo_device": "suservo"},
            }
        }
    )

# Sampler
device_db["spi_sampler_pgia"] = {
    "type": "local",
    "module": "artiq.coredevice.spi2",
    "class": "SPIMaster",
    "arguments": {"channel": 43},
}

# Two Urukuls
for i in range(2):
    device_db.update(
        {
            "spi_urukul"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.spi2",
                "class": "SPIMaster",
                "arguments": {"channel": 44 + i},
            },
            "urukul"
            + str(i)
            + "_cpld": {
                "type": "local",
                "module": "artiq.coredevice.urukul",
                "class": "CPLD",
                "arguments": {
                    "spi_device": "spi_urukul" + str(i),
                    "refclk": 125000000.0,
                    "clk_sel": 2,
                },
            },
            "urukul"
            + str(i)
            + "_dds": {
                "type": "local",
                "module": "artiq.coredevice.ad9910",
                "class": "AD9910",
                "arguments": {
                    "pll_n": 32,
                    "chip_select": 3,
                    "cpld_device": "urukul" + str(i) + "_cpld",
                },
            },
        }
    )

# 2 front panel user controllable LEDs
for i in range(3):
    device_db.update(
        {
            "led"
            + str(i): {
                "type": "local",
                "module": "artiq.coredevice.ttl",
                "class": "TTLOut",
                "arguments": {"channel": 46 + i},
            }
        }
    )

# Toptica Lasers
device_db.update(
    {
        "toptica_780": {
            "type": "local",
            "module": "controllers.driver_topticadlc",
            "class": "TopticaDLCPro",
            "arguments": {
                "ip": "192.168.0.4",
                "laser": "laser2",
                "simulation": False,
            },
        },
        "toptica_852": {
            "type": "local",
            "module": "controllers.driver_topticadlc",
            "class": "TopticaDLCPro",
            "arguments": {
                "ip": "192.168.0.4",
                "laser": "laser1",
                "simulation": False,
            },
        },
        "topticaDLC": {
            "type": "controller",
            "host": server_addr,
            "port": 3272,
            "command": "python controllers.aqctl_topticadlc.py -ip 192.168.0.4",
        },
    }
)

# Aliases
aliases = {
    # photodiode on 3DMOT - given we don't enable servoing for the locking arm
    "MOT_photodiode": "suservo_ch0",
    # 780 MOT
    "suservo_aom_LOCK": "suservo_ch0",
    "suservo_aom_MOT": "suservo_ch1",
    "suservo_aom_IMG": "suservo_ch2",
    "suservo_aom_PUMP": "suservo_ch3",
    "mirny_eom_repump": "mirny_ch0",
    "almazny_eom_repump": "almazny_ch0",
    "shutter_2DMOT": "ttl0",
    "shutter_3DMOT": "ttl1",
    # 852 Lattice
    "suservo_aom_LATX": "suservo_ch4",
    "suservo_aom_LATY": "suservo_ch5",
    # 1064 Cross Dipole Trap
    "suservo_aom_CDT1": "suservo_ch6",
    "suservo_aom_CDT2": "suservo_ch7",
}

device_db |= aliases
